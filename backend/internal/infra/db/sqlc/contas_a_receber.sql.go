// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: contas_a_receber.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const countContasReceberByStatus = `-- name: CountContasReceberByStatus :one
SELECT COUNT(*) FROM contas_a_receber
WHERE tenant_id = $1 AND status = $2
`

type CountContasReceberByStatusParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Status   *string     `json:"status"`
}

func (q *Queries) CountContasReceberByStatus(ctx context.Context, arg CountContasReceberByStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, countContasReceberByStatus, arg.TenantID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countContasReceberByTenant = `-- name: CountContasReceberByTenant :one
SELECT COUNT(*) FROM contas_a_receber
WHERE tenant_id = $1
`

func (q *Queries) CountContasReceberByTenant(ctx context.Context, tenantID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countContasReceberByTenant, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createContaReceber = `-- name: CreateContaReceber :one
INSERT INTO contas_a_receber (
    tenant_id,
    origem,
    assinatura_id,
    servico_id,
    descricao,
    valor,
    valor_pago,
    data_vencimento,
    data_recebimento,
    status,
    observacoes
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, tenant_id, origem, assinatura_id, servico_id, descricao, valor, valor_pago, data_vencimento, data_recebimento, status, observacoes, criado_em, atualizado_em
`

type CreateContaReceberParams struct {
	TenantID        pgtype.UUID     `json:"tenant_id"`
	Origem          *string         `json:"origem"`
	AssinaturaID    pgtype.UUID     `json:"assinatura_id"`
	ServicoID       pgtype.UUID     `json:"servico_id"`
	Descricao       string          `json:"descricao"`
	Valor           decimal.Decimal `json:"valor"`
	ValorPago       pgtype.Numeric  `json:"valor_pago"`
	DataVencimento  pgtype.Date     `json:"data_vencimento"`
	DataRecebimento pgtype.Date     `json:"data_recebimento"`
	Status          *string         `json:"status"`
	Observacoes     *string         `json:"observacoes"`
}

func (q *Queries) CreateContaReceber(ctx context.Context, arg CreateContaReceberParams) (ContasAReceber, error) {
	row := q.db.QueryRow(ctx, createContaReceber,
		arg.TenantID,
		arg.Origem,
		arg.AssinaturaID,
		arg.ServicoID,
		arg.Descricao,
		arg.Valor,
		arg.ValorPago,
		arg.DataVencimento,
		arg.DataRecebimento,
		arg.Status,
		arg.Observacoes,
	)
	var i ContasAReceber
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Origem,
		&i.AssinaturaID,
		&i.ServicoID,
		&i.Descricao,
		&i.Valor,
		&i.ValorPago,
		&i.DataVencimento,
		&i.DataRecebimento,
		&i.Status,
		&i.Observacoes,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const deleteContaReceber = `-- name: DeleteContaReceber :exec
DELETE FROM contas_a_receber
WHERE id = $1 AND tenant_id = $2
`

type DeleteContaReceberParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteContaReceber(ctx context.Context, arg DeleteContaReceberParams) error {
	_, err := q.db.Exec(ctx, deleteContaReceber, arg.ID, arg.TenantID)
	return err
}

const getContaReceberByID = `-- name: GetContaReceberByID :one
SELECT id, tenant_id, origem, assinatura_id, servico_id, descricao, valor, valor_pago, data_vencimento, data_recebimento, status, observacoes, criado_em, atualizado_em FROM contas_a_receber
WHERE id = $1 AND tenant_id = $2
`

type GetContaReceberByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetContaReceberByID(ctx context.Context, arg GetContaReceberByIDParams) (ContasAReceber, error) {
	row := q.db.QueryRow(ctx, getContaReceberByID, arg.ID, arg.TenantID)
	var i ContasAReceber
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Origem,
		&i.AssinaturaID,
		&i.ServicoID,
		&i.Descricao,
		&i.Valor,
		&i.ValorPago,
		&i.DataVencimento,
		&i.DataRecebimento,
		&i.Status,
		&i.Observacoes,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const listContasReceberByAssinatura = `-- name: ListContasReceberByAssinatura :many
SELECT id, tenant_id, origem, assinatura_id, servico_id, descricao, valor, valor_pago, data_vencimento, data_recebimento, status, observacoes, criado_em, atualizado_em FROM contas_a_receber
WHERE tenant_id = $1 AND assinatura_id = $2
ORDER BY data_vencimento DESC
`

type ListContasReceberByAssinaturaParams struct {
	TenantID     pgtype.UUID `json:"tenant_id"`
	AssinaturaID pgtype.UUID `json:"assinatura_id"`
}

func (q *Queries) ListContasReceberByAssinatura(ctx context.Context, arg ListContasReceberByAssinaturaParams) ([]ContasAReceber, error) {
	rows, err := q.db.Query(ctx, listContasReceberByAssinatura, arg.TenantID, arg.AssinaturaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ContasAReceber{}
	for rows.Next() {
		var i ContasAReceber
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Origem,
			&i.AssinaturaID,
			&i.ServicoID,
			&i.Descricao,
			&i.Valor,
			&i.ValorPago,
			&i.DataVencimento,
			&i.DataRecebimento,
			&i.Status,
			&i.Observacoes,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContasReceberByOrigem = `-- name: ListContasReceberByOrigem :many
SELECT id, tenant_id, origem, assinatura_id, servico_id, descricao, valor, valor_pago, data_vencimento, data_recebimento, status, observacoes, criado_em, atualizado_em FROM contas_a_receber
WHERE tenant_id = $1 AND origem = $2
ORDER BY data_vencimento DESC
LIMIT $3 OFFSET $4
`

type ListContasReceberByOrigemParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Origem   *string     `json:"origem"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) ListContasReceberByOrigem(ctx context.Context, arg ListContasReceberByOrigemParams) ([]ContasAReceber, error) {
	rows, err := q.db.Query(ctx, listContasReceberByOrigem,
		arg.TenantID,
		arg.Origem,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ContasAReceber{}
	for rows.Next() {
		var i ContasAReceber
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Origem,
			&i.AssinaturaID,
			&i.ServicoID,
			&i.Descricao,
			&i.Valor,
			&i.ValorPago,
			&i.DataVencimento,
			&i.DataRecebimento,
			&i.Status,
			&i.Observacoes,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContasReceberByPeriod = `-- name: ListContasReceberByPeriod :many
SELECT id, tenant_id, origem, assinatura_id, servico_id, descricao, valor, valor_pago, data_vencimento, data_recebimento, status, observacoes, criado_em, atualizado_em FROM contas_a_receber
WHERE tenant_id = $1
  AND data_vencimento >= $2
  AND data_vencimento <= $3
ORDER BY data_vencimento ASC
`

type ListContasReceberByPeriodParams struct {
	TenantID         pgtype.UUID `json:"tenant_id"`
	DataVencimento   pgtype.Date `json:"data_vencimento"`
	DataVencimento_2 pgtype.Date `json:"data_vencimento_2"`
}

func (q *Queries) ListContasReceberByPeriod(ctx context.Context, arg ListContasReceberByPeriodParams) ([]ContasAReceber, error) {
	rows, err := q.db.Query(ctx, listContasReceberByPeriod, arg.TenantID, arg.DataVencimento, arg.DataVencimento_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ContasAReceber{}
	for rows.Next() {
		var i ContasAReceber
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Origem,
			&i.AssinaturaID,
			&i.ServicoID,
			&i.Descricao,
			&i.Valor,
			&i.ValorPago,
			&i.DataVencimento,
			&i.DataRecebimento,
			&i.Status,
			&i.Observacoes,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContasReceberByStatus = `-- name: ListContasReceberByStatus :many
SELECT id, tenant_id, origem, assinatura_id, servico_id, descricao, valor, valor_pago, data_vencimento, data_recebimento, status, observacoes, criado_em, atualizado_em FROM contas_a_receber
WHERE tenant_id = $1 AND status = $2
ORDER BY data_vencimento ASC
LIMIT $3 OFFSET $4
`

type ListContasReceberByStatusParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Status   *string     `json:"status"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) ListContasReceberByStatus(ctx context.Context, arg ListContasReceberByStatusParams) ([]ContasAReceber, error) {
	rows, err := q.db.Query(ctx, listContasReceberByStatus,
		arg.TenantID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ContasAReceber{}
	for rows.Next() {
		var i ContasAReceber
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Origem,
			&i.AssinaturaID,
			&i.ServicoID,
			&i.Descricao,
			&i.Valor,
			&i.ValorPago,
			&i.DataVencimento,
			&i.DataRecebimento,
			&i.Status,
			&i.Observacoes,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContasReceberByTenant = `-- name: ListContasReceberByTenant :many
SELECT id, tenant_id, origem, assinatura_id, servico_id, descricao, valor, valor_pago, data_vencimento, data_recebimento, status, observacoes, criado_em, atualizado_em FROM contas_a_receber
WHERE tenant_id = $1
ORDER BY data_vencimento DESC
LIMIT $2 OFFSET $3
`

type ListContasReceberByTenantParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) ListContasReceberByTenant(ctx context.Context, arg ListContasReceberByTenantParams) ([]ContasAReceber, error) {
	rows, err := q.db.Query(ctx, listContasReceberByTenant, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ContasAReceber{}
	for rows.Next() {
		var i ContasAReceber
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Origem,
			&i.AssinaturaID,
			&i.ServicoID,
			&i.Descricao,
			&i.Valor,
			&i.ValorPago,
			&i.DataVencimento,
			&i.DataRecebimento,
			&i.Status,
			&i.Observacoes,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContasReceberVencidas = `-- name: ListContasReceberVencidas :many
SELECT id, tenant_id, origem, assinatura_id, servico_id, descricao, valor, valor_pago, data_vencimento, data_recebimento, status, observacoes, criado_em, atualizado_em FROM contas_a_receber
WHERE tenant_id = $1
  AND status IN ('PENDENTE', 'ATRASADO')
  AND data_vencimento < $2
ORDER BY data_vencimento ASC
`

type ListContasReceberVencidasParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	DataVencimento pgtype.Date `json:"data_vencimento"`
}

func (q *Queries) ListContasReceberVencidas(ctx context.Context, arg ListContasReceberVencidasParams) ([]ContasAReceber, error) {
	rows, err := q.db.Query(ctx, listContasReceberVencidas, arg.TenantID, arg.DataVencimento)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ContasAReceber{}
	for rows.Next() {
		var i ContasAReceber
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.Origem,
			&i.AssinaturaID,
			&i.ServicoID,
			&i.Descricao,
			&i.Valor,
			&i.ValorPago,
			&i.DataVencimento,
			&i.DataRecebimento,
			&i.Status,
			&i.Observacoes,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const marcarContaReceberComoAtrasada = `-- name: MarcarContaReceberComoAtrasada :exec
UPDATE contas_a_receber
SET
    status = 'ATRASADO',
    atualizado_em = NOW()
WHERE tenant_id = $1
  AND status = 'PENDENTE'
  AND data_vencimento < $2
`

type MarcarContaReceberComoAtrasadaParams struct {
	TenantID       pgtype.UUID `json:"tenant_id"`
	DataVencimento pgtype.Date `json:"data_vencimento"`
}

func (q *Queries) MarcarContaReceberComoAtrasada(ctx context.Context, arg MarcarContaReceberComoAtrasadaParams) error {
	_, err := q.db.Exec(ctx, marcarContaReceberComoAtrasada, arg.TenantID, arg.DataVencimento)
	return err
}

const marcarContaReceberComoRecebida = `-- name: MarcarContaReceberComoRecebida :one
UPDATE contas_a_receber
SET
    status = 'RECEBIDO',
    data_recebimento = $3,
    valor_pago = $4,
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, origem, assinatura_id, servico_id, descricao, valor, valor_pago, data_vencimento, data_recebimento, status, observacoes, criado_em, atualizado_em
`

type MarcarContaReceberComoRecebidaParams struct {
	ID              pgtype.UUID    `json:"id"`
	TenantID        pgtype.UUID    `json:"tenant_id"`
	DataRecebimento pgtype.Date    `json:"data_recebimento"`
	ValorPago       pgtype.Numeric `json:"valor_pago"`
}

func (q *Queries) MarcarContaReceberComoRecebida(ctx context.Context, arg MarcarContaReceberComoRecebidaParams) (ContasAReceber, error) {
	row := q.db.QueryRow(ctx, marcarContaReceberComoRecebida,
		arg.ID,
		arg.TenantID,
		arg.DataRecebimento,
		arg.ValorPago,
	)
	var i ContasAReceber
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Origem,
		&i.AssinaturaID,
		&i.ServicoID,
		&i.Descricao,
		&i.Valor,
		&i.ValorPago,
		&i.DataVencimento,
		&i.DataRecebimento,
		&i.Status,
		&i.Observacoes,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const sumContasReceberByPeriod = `-- name: SumContasReceberByPeriod :one
SELECT
    COALESCE(SUM(valor), 0) as total_a_receber
FROM contas_a_receber
WHERE tenant_id = $1
  AND data_vencimento >= $2
  AND data_vencimento <= $3
  AND status != 'CANCELADO'
`

type SumContasReceberByPeriodParams struct {
	TenantID         pgtype.UUID `json:"tenant_id"`
	DataVencimento   pgtype.Date `json:"data_vencimento"`
	DataVencimento_2 pgtype.Date `json:"data_vencimento_2"`
}

func (q *Queries) SumContasReceberByPeriod(ctx context.Context, arg SumContasReceberByPeriodParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, sumContasReceberByPeriod, arg.TenantID, arg.DataVencimento, arg.DataVencimento_2)
	var total_a_receber interface{}
	err := row.Scan(&total_a_receber)
	return total_a_receber, err
}

const sumContasRecebidasByPeriod = `-- name: SumContasRecebidasByPeriod :one
SELECT
    COALESCE(SUM(valor_pago), 0) as total_recebido
FROM contas_a_receber
WHERE tenant_id = $1
  AND data_recebimento >= $2
  AND data_recebimento <= $3
  AND status = 'RECEBIDO'
`

type SumContasRecebidasByPeriodParams struct {
	TenantID          pgtype.UUID `json:"tenant_id"`
	DataRecebimento   pgtype.Date `json:"data_recebimento"`
	DataRecebimento_2 pgtype.Date `json:"data_recebimento_2"`
}

func (q *Queries) SumContasRecebidasByPeriod(ctx context.Context, arg SumContasRecebidasByPeriodParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, sumContasRecebidasByPeriod, arg.TenantID, arg.DataRecebimento, arg.DataRecebimento_2)
	var total_recebido interface{}
	err := row.Scan(&total_recebido)
	return total_recebido, err
}

const updateContaReceber = `-- name: UpdateContaReceber :one
UPDATE contas_a_receber
SET
    descricao = $3,
    valor = $4,
    valor_pago = $5,
    data_vencimento = $6,
    data_recebimento = $7,
    status = $8,
    observacoes = $9,
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, origem, assinatura_id, servico_id, descricao, valor, valor_pago, data_vencimento, data_recebimento, status, observacoes, criado_em, atualizado_em
`

type UpdateContaReceberParams struct {
	ID              pgtype.UUID     `json:"id"`
	TenantID        pgtype.UUID     `json:"tenant_id"`
	Descricao       string          `json:"descricao"`
	Valor           decimal.Decimal `json:"valor"`
	ValorPago       pgtype.Numeric  `json:"valor_pago"`
	DataVencimento  pgtype.Date     `json:"data_vencimento"`
	DataRecebimento pgtype.Date     `json:"data_recebimento"`
	Status          *string         `json:"status"`
	Observacoes     *string         `json:"observacoes"`
}

func (q *Queries) UpdateContaReceber(ctx context.Context, arg UpdateContaReceberParams) (ContasAReceber, error) {
	row := q.db.QueryRow(ctx, updateContaReceber,
		arg.ID,
		arg.TenantID,
		arg.Descricao,
		arg.Valor,
		arg.ValorPago,
		arg.DataVencimento,
		arg.DataRecebimento,
		arg.Status,
		arg.Observacoes,
	)
	var i ContasAReceber
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.Origem,
		&i.AssinaturaID,
		&i.ServicoID,
		&i.Descricao,
		&i.Valor,
		&i.ValorPago,
		&i.DataVencimento,
		&i.DataRecebimento,
		&i.Status,
		&i.Observacoes,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}
