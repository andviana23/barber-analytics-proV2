// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: metas_mensais.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const aprovarMetaMensal = `-- name: AprovarMetaMensal :one
UPDATE metas_mensais
SET
    status = 'ACEITA',
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, mes_ano, meta_faturamento, origem, status, criado_por, criado_em, atualizado_em
`

type AprovarMetaMensalParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) AprovarMetaMensal(ctx context.Context, arg AprovarMetaMensalParams) (MetasMensai, error) {
	row := q.db.QueryRow(ctx, aprovarMetaMensal, arg.ID, arg.TenantID)
	var i MetasMensai
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.MesAno,
		&i.MetaFaturamento,
		&i.Origem,
		&i.Status,
		&i.CriadoPor,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const countMetasMensaisByTenant = `-- name: CountMetasMensaisByTenant :one
SELECT COUNT(*) FROM metas_mensais
WHERE tenant_id = $1
`

func (q *Queries) CountMetasMensaisByTenant(ctx context.Context, tenantID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countMetasMensaisByTenant, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMetaMensal = `-- name: CreateMetaMensal :one
INSERT INTO metas_mensais (
    tenant_id,
    mes_ano,
    meta_faturamento,
    origem,
    status,
    criado_por
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, tenant_id, mes_ano, meta_faturamento, origem, status, criado_por, criado_em, atualizado_em
`

type CreateMetaMensalParams struct {
	TenantID        pgtype.UUID     `json:"tenant_id"`
	MesAno          string          `json:"mes_ano"`
	MetaFaturamento decimal.Decimal `json:"meta_faturamento"`
	Origem          *string         `json:"origem"`
	Status          *string         `json:"status"`
	CriadoPor       pgtype.UUID     `json:"criado_por"`
}

func (q *Queries) CreateMetaMensal(ctx context.Context, arg CreateMetaMensalParams) (MetasMensai, error) {
	row := q.db.QueryRow(ctx, createMetaMensal,
		arg.TenantID,
		arg.MesAno,
		arg.MetaFaturamento,
		arg.Origem,
		arg.Status,
		arg.CriadoPor,
	)
	var i MetasMensai
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.MesAno,
		&i.MetaFaturamento,
		&i.Origem,
		&i.Status,
		&i.CriadoPor,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const deleteMetaMensal = `-- name: DeleteMetaMensal :exec
DELETE FROM metas_mensais
WHERE id = $1 AND tenant_id = $2
`

type DeleteMetaMensalParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteMetaMensal(ctx context.Context, arg DeleteMetaMensalParams) error {
	_, err := q.db.Exec(ctx, deleteMetaMensal, arg.ID, arg.TenantID)
	return err
}

const getMetaMensalByID = `-- name: GetMetaMensalByID :one
SELECT id, tenant_id, mes_ano, meta_faturamento, origem, status, criado_por, criado_em, atualizado_em FROM metas_mensais
WHERE id = $1 AND tenant_id = $2
`

type GetMetaMensalByIDParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetMetaMensalByID(ctx context.Context, arg GetMetaMensalByIDParams) (MetasMensai, error) {
	row := q.db.QueryRow(ctx, getMetaMensalByID, arg.ID, arg.TenantID)
	var i MetasMensai
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.MesAno,
		&i.MetaFaturamento,
		&i.Origem,
		&i.Status,
		&i.CriadoPor,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const getMetaMensalByMesAno = `-- name: GetMetaMensalByMesAno :one
SELECT id, tenant_id, mes_ano, meta_faturamento, origem, status, criado_por, criado_em, atualizado_em FROM metas_mensais
WHERE tenant_id = $1 AND mes_ano = $2
`

type GetMetaMensalByMesAnoParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	MesAno   string      `json:"mes_ano"`
}

func (q *Queries) GetMetaMensalByMesAno(ctx context.Context, arg GetMetaMensalByMesAnoParams) (MetasMensai, error) {
	row := q.db.QueryRow(ctx, getMetaMensalByMesAno, arg.TenantID, arg.MesAno)
	var i MetasMensai
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.MesAno,
		&i.MetaFaturamento,
		&i.Origem,
		&i.Status,
		&i.CriadoPor,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const listMetasMensaisByPeriod = `-- name: ListMetasMensaisByPeriod :many
SELECT id, tenant_id, mes_ano, meta_faturamento, origem, status, criado_por, criado_em, atualizado_em FROM metas_mensais
WHERE tenant_id = $1
  AND mes_ano >= $2
  AND mes_ano <= $3
ORDER BY mes_ano DESC
`

type ListMetasMensaisByPeriodParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	MesAno   string      `json:"mes_ano"`
	MesAno_2 string      `json:"mes_ano_2"`
}

func (q *Queries) ListMetasMensaisByPeriod(ctx context.Context, arg ListMetasMensaisByPeriodParams) ([]MetasMensai, error) {
	rows, err := q.db.Query(ctx, listMetasMensaisByPeriod, arg.TenantID, arg.MesAno, arg.MesAno_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MetasMensai{}
	for rows.Next() {
		var i MetasMensai
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.MesAno,
			&i.MetaFaturamento,
			&i.Origem,
			&i.Status,
			&i.CriadoPor,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMetasMensaisByStatus = `-- name: ListMetasMensaisByStatus :many
SELECT id, tenant_id, mes_ano, meta_faturamento, origem, status, criado_por, criado_em, atualizado_em FROM metas_mensais
WHERE tenant_id = $1 AND status = $2
ORDER BY mes_ano DESC
LIMIT $3 OFFSET $4
`

type ListMetasMensaisByStatusParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Status   *string     `json:"status"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) ListMetasMensaisByStatus(ctx context.Context, arg ListMetasMensaisByStatusParams) ([]MetasMensai, error) {
	rows, err := q.db.Query(ctx, listMetasMensaisByStatus,
		arg.TenantID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MetasMensai{}
	for rows.Next() {
		var i MetasMensai
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.MesAno,
			&i.MetaFaturamento,
			&i.Origem,
			&i.Status,
			&i.CriadoPor,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMetasMensaisByTenant = `-- name: ListMetasMensaisByTenant :many
SELECT id, tenant_id, mes_ano, meta_faturamento, origem, status, criado_por, criado_em, atualizado_em FROM metas_mensais
WHERE tenant_id = $1
ORDER BY mes_ano DESC
LIMIT $2 OFFSET $3
`

type ListMetasMensaisByTenantParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) ListMetasMensaisByTenant(ctx context.Context, arg ListMetasMensaisByTenantParams) ([]MetasMensai, error) {
	rows, err := q.db.Query(ctx, listMetasMensaisByTenant, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MetasMensai{}
	for rows.Next() {
		var i MetasMensai
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.MesAno,
			&i.MetaFaturamento,
			&i.Origem,
			&i.Status,
			&i.CriadoPor,
			&i.CriadoEm,
			&i.AtualizadoEm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rejeitarMetaMensal = `-- name: RejeitarMetaMensal :one
UPDATE metas_mensais
SET
    status = 'REJEITADA',
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, mes_ano, meta_faturamento, origem, status, criado_por, criado_em, atualizado_em
`

type RejeitarMetaMensalParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) RejeitarMetaMensal(ctx context.Context, arg RejeitarMetaMensalParams) (MetasMensai, error) {
	row := q.db.QueryRow(ctx, rejeitarMetaMensal, arg.ID, arg.TenantID)
	var i MetasMensai
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.MesAno,
		&i.MetaFaturamento,
		&i.Origem,
		&i.Status,
		&i.CriadoPor,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}

const updateMetaMensal = `-- name: UpdateMetaMensal :one
UPDATE metas_mensais
SET
    meta_faturamento = $3,
    origem = $4,
    status = $5,
    atualizado_em = NOW()
WHERE id = $1 AND tenant_id = $2
RETURNING id, tenant_id, mes_ano, meta_faturamento, origem, status, criado_por, criado_em, atualizado_em
`

type UpdateMetaMensalParams struct {
	ID              pgtype.UUID     `json:"id"`
	TenantID        pgtype.UUID     `json:"tenant_id"`
	MetaFaturamento decimal.Decimal `json:"meta_faturamento"`
	Origem          *string         `json:"origem"`
	Status          *string         `json:"status"`
}

func (q *Queries) UpdateMetaMensal(ctx context.Context, arg UpdateMetaMensalParams) (MetasMensai, error) {
	row := q.db.QueryRow(ctx, updateMetaMensal,
		arg.ID,
		arg.TenantID,
		arg.MetaFaturamento,
		arg.Origem,
		arg.Status,
	)
	var i MetasMensai
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.MesAno,
		&i.MetaFaturamento,
		&i.Origem,
		&i.Status,
		&i.CriadoPor,
		&i.CriadoEm,
		&i.AtualizadoEm,
	)
	return i, err
}
